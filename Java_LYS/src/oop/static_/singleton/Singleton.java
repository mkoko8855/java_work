package oop.static_.singleton;

public class Singleton {

	
	 /*
	 		싱글톤 디자인 패턴 : 클래스의 객체를 단 1개로 제한하기 위한 코드 디자인 패턴. (1개만으로 돌려 가며 사용 할 수 있도록)
	 		
	 		외부에선 싱글톤 이라는 객체를 생성하지 못하게 하려면, 첫번째 순서는 생성자에 프라이빗을 쓴다.
	 		
	 		1. 외부에서 이 클래스의 객체를 생성하지 못하게 생성자를 단 1개만 선언하고,
	 		   생성자를 private 접근 제한을 붙임.
	 		   
	 		2. 생성자를 호출 할 수 있는 영역은 같은 클래스 내부 뿐이므로 자신의 클래스 내부에서 스스로의 객체를 단 1개만 생성한다.   
	 		   
	 		   
	 		3. 외부에서 이 클래스의 객체를 요구할 시, 2번에서 미리 만들어 놓은 단 하나의 객체의 주소값을 공개된 메서드를 통해 제공한다.(리턴한다.)   
	 */
	
	
	private Singleton() {  //프라이빗으로 막자, 그럼 외부에서는 이 생성자를 호출 할 수가 없다.
		System.out.println("객체가 생성됨!");
	}
	
	
	
	//외부에서 객체 못만들게 막았다면(생성자 막았으니까)
	//2. 생성자를 호출 할 수 있는 영역은 같은 클래스 내부 뿐이므로 자신의 클래스 내부에서 스스로의 객체를 단 1개만 생성한다.
	//(private은 아래에서 설명함. 일단 붙여놨음, 외부로부터 s라는 존재 자체를 숨겨주기 위해 static 앞에 private를 붙임)
	private static Singleton s = new Singleton(); // 같은 클래스 내부 이므로 여기서만 객체를 만들 수 있음
	
	
	
	//3. 외부에서 이 클래스의 객체를 요구할 시, 2번에서 미리 만들어 놓은 단 하나의 객체의 주소값을 공개된 메서드를 통해 제공한다.(리턴한다.)   
	//이제 객체를 리턴하는 공개된 메서드를 만들자
	public static Singleton getInstance() { //근데 getinstance는 메서드잖아. 근데 객체를 못만들어. 그럼 말이 안되잖아?
											//호출하려면 객체 생성 없이도 제공을 해야 겠지? 바로 static을 넣어준다.!!
											//그럼 아래 returnn s;에 빨간줄 들어 오는데, 객체에 만드는 29번째 줄에 static붙여주면 된다
		
		return s; //s라는 주소만 빌려줘서 상대방들이 s라는 주소에 접근할 수 있게 해주는 것이다.
	}
	
	
	//그러나 3단계까지했다고 끝난게 아니라. return s는 위의 static Singleton s = new Singleton(); 이걸 가리키기 때문이다.
	//사용은 static으로 하되, static Singleton s = new Singleton();에 private을 붙여준다.

	
	
	
	
	
	
	
	
	
	
	
	
	////////////////////////////////////////////////////////////////////////////////////
	
	
	public void method1() {
		System.out.println("여러 군데에서 쓰이는 중요한 메서드");
	}
	
	public void method2() {
		System.out.println("꼭 사용해야 하는 귀한 메서드");
	}
	
	
	
	
	
	
	
	
}
