package oop.inherit.good;

/*
 
 # 이 워리어 클래스는 자식 클래스, 하위 클래스 (child, Sub class)라고 한다.
 
 - 부모 클래스로부터 멤버변수(필드)와 메서드를 물려 받는 클래스를
   자식 클래스 라고 한다.
   
 - 상속을 적용 시키려면 자식 클래스 선언부에 클래스 이름을 뒤에 키워드인 extends를 쓰고 물려 받을 부모 클래스의 이름을 적는다.
 
 
 */

public class Warrior extends Player {

	int rage;

	
	
	
	
	 /*
	 
	  	# 메서드 오버라이딩(재정의)
	  	
	  	- 부모가 물려주는 메서드는 모든 자식들에게 다 맞게 설계되기 힘들기 때문에 (다받을 수 없기 때문에)
	  	
	  	- 부족한 점이 있거나 아예 맞지 않는 경우에는 자식 클래스 쪽에서 내용을 추가 하거나 수정 할 수 있다. 이를 오버라이딩 이라고 한다.
	  
	  	- 만약 자식 클래스에서 부모가 물려준 메서드를 새롭게 재 정의 한다면 자식이 수정한 메서드가 우선적으로 호출된다.
	  	
	  	
	  	- 오버 라이딩의 규칙은 다음과 같다 (3가지 모두 일치해야 오버라이딩 으로 인정이 된다)
	  	
	  	1. 부모가 물려주는 메서드와 이름이 동일해야 한다.
	  	
	  	2. 부모가 물려주는 메서드와 리턴 타입이 똑같아야 한다.
	  	
	  	3. 부모가 물려주는 메서드와 매개변수의 선언 방식이 똑같아야 한다.
	  
	 */
	
	
	
	
	
	
	
	
	
	
//	void characterInfo() {
								//부모가 물려준 클래스를 나에게 맞게 재정의 한다 라는 것이 바로 메서드 오버라이딩 이다.
//		super.characterInfo();  //오버라이딩 부분 > 부모의 캐릭터인포를 먼저 부르고 출력 하겠다 하고 메인클래스가서 출력 결과를 확인하면 분노까지 출력이 된다.
								//Player라는 조상과 비교시, 오버라이딩을 생각한다면 
								//메서드 이름과 같지?, 리턴타입이 보이드로 똑같지? 매개변수도 똑같이 선언되어 있지 않지? 이것이 오버라이딩의 규칙이 합당함.
//		System.out.println("분노 : " + rage); 
		
	
	
			   // 위 는 잠깐 주석, 오버라이딩은 alt + shift + s 하면 편하게 할 수 있음(override/implemet methods를 누르고 선택하면 된다.)
	@Override  //어노테이션은 기능이 있는 주석이다. 오버라이딩 문법이 맞는지 체크해주는 간단한 기능이 있다. 
			   //이걸보고 이 캐릭터인포 메서드는 부모가 물려준 거에서 새롭게 정의됐다는 걸 알 수 있다.
	void characterInfo() {
		super.characterInfo();
		System.out.println("분노 : " + rage); 
	}   // 이렇게 자동 완성 됨.
}
