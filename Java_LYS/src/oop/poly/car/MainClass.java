package oop.poly.car;

public class MainClass {

	public static void main(String[] args) {

										//		다 형 성 사 용 방 법
		
		
		//소나타를 3대 만들었다.
		Sonata s1 = new Sonata();
		Sonata s2 = new Sonata();
		Sonata s3 = new Sonata();
		
		//포르쉐를 3대 만들었다.
		Porsche p1 = new Porsche();
		Porsche p2 = new Porsche();
		Porsche p3 = new Porsche();
		
		//테슬라를 4대 만들었다.
		Tesla t1 = new Tesla();
		Tesla t2 = new Tesla();
		Tesla t3 = new Tesla();
		Tesla t4 = new Tesla();
		
		
		
		
		
		//s1.run(), t1.run(), p1.run() 이런식보다 더 쉽게 배열로 생성하자
		
//		Sonata[] sonatas = {s1, s2, s3};   //여기에 t1 쓰면 안됨. 같은 타입의 데이터들만 집합이 가능하기 때문에 t1이나 p1 같은 건 절대 안됨.
//		for(Sonata s : sonatas) {
//			s.run();     //출력 결과 : 소나타가 갑니다 가요
						 //			소나타가 갑니다 가요
						 //			소나타가 갑니다 가요			
			
//		}
		
		
		
		
		
		
		//포르쉐와 테슬라는 배열을 각자 선언 해줘야 하긴 한다.
//		Tesla[] teslas = {t1, t2, t3, t4};
//		for(Tesla t : teslas) {
//			t.run();
//		}
		
		
		
		
		
		
		
		//근데 자동차의 개수가 얼마나 많을텐데 배열을 굉장히 많이 써야해. 불편하니까 다른 방법쓰자
		//모든 자동차가 달려야 하는걸 출력을 하고 싶은데, 그럼 다형성을 사용하면 된다.
		
		//이 객체 안엔 Car 타입의 주소값에는 Car타입의 모든 자식들까지도 올 수 있다.
		Car[] cars = {s1, s2, s3, p1, p2, p3, t1, t2, t3, t4};   
		//서로 다른 종들도 모아 놓을 수 있는 것이 다형성이다. (서로 상속관계가 되어 있어야 가능)
		//즉, 다형성을 적용해서 이종모음 배열을 선언 할 수 있다.
		for(Car c : cars) {
			//Car c에는 소나타 객체가 들어올 수 있다. 왜? c는 부모 타입의 변수니까.
			c.run();
			
			//출력 결과 :
			/*
			소나타가 갑니다 가요
			소나타가 갑니다 가요
			소나타가 갑니다 가요
			포르쉐다 길비켜라.
			포르쉐다 길비켜라.
			포르쉐다 길비켜라.
			테슬라가 나갑니다~.
			테슬라가 나갑니다~.
			테슬라가 나갑니다~.
			테슬라가 나갑니다~.
			*/
		}
		
		
		
		
		
		
		System.out.println("---------------------------------------------------------------------------");
		
		
		
		
		
		
		//타이어를 띄우자
		System.out.println("*** 타이어 교체 작업! ***");
		t1.frontLeft  = new HTire();
		t1.frontRight = new HTire();
		t1.rearLeft = new HTire();
		t1.rearLeft = new HTire(); //뒷바퀴담당이 넥센타이어이여도 타이어는 4개 모두 같은 타이어를 끼워야지..
		
		//어떤 브랜드든 끼어넣고싶어. 그럼 어떻게 하면 좋을까? 다형성 발생 시키자. 
		//클래스를 하나 더 만들자. 타이어들의 부모가 될 클래스를 만들어서 모든 타이어가 그것을 상속하게 하자.
		//Tire 클래스를 만들고, NTire클래스와 HTire클래스에 extends Tire을 써주자.
		//그리고 Car클래스에 가서 멤버변수를 모두 Tire로 통일을 시켜 준 후, 다시 메인클레스 중 이곳에 와서 new HTire로 객체를 통일 시켜주면
		//다형성 완성이다. 이것이 멤버변수의 다형성
		
		
		
		System.out.println("--------------------------------------------------------------------------♥");
		
		
		//그럼 위에서 멤버변수의 다형성 알아봤다고 끝? 아니다.  매개변수 다형성을 알아보기 위해 Driver 클래스를 하나 만들어 주자.
		
		
		//Driver클래스 만들었고, 메인으로가서 드라이버클래스를 호출 시켜 보자.
		
		//Driver kim = new Driver();
		//kim.drive(s1);   
		//출력 결과 :
		/*
		운전을 시작합니다.
		소나타가 갑니다 가요
		*/
		//s2 든 s3든 다 가능하지만 테슬라인 t1은 안된다. 왜냐? 드라이브라는 메서드는 Sonata s라는(의) 객체를 전달받는다했잖아..그러니 안됨.
		
		
		//그럼 오버로딩 해야지 다시 드라이버클래스 ㄱㄱ
		//kim.drive(t1);
		
		//하지만 위는 테슬라니깐 t1이 출력 되겠지만 포르쉐인 p1은 안된다. 자동차의 타입이 많아지면 힘들다. 즉, 우리가 알 수 있는 것은 오버로딩도 한계가 있는 것이다.
		
		
		//그럼 다형성을 또 적용 시켜봐야겠지
		//매개변수의 다형성을 적용 시켜보자. 아까는 멤버변수의 다형성 이였다.
		
		
		//작성했으면 메인으로 가보자. 왔다.
		Driver kim = new Driver();
		kim.drive(p1);
		kim.drive(s2);
		kim.drive(t3);
		//이렇게 다 되는 걸 확인 할 수 있다.
		
		
		
		
		
		
		
		
		
		
		//이제 호출하러 메인클래스 가자
		//리턴 다형성 확인해보러 왔다.
		//Tesla t5 = kim.buyCar("테슬라");  //메서드 내에서는 return new Tesla();로, 테슬라 타입으로 리턴이 되는 줄 알았지만
										  //buyCar는 부모 타입이다. 만약 Tesla t5에서, Tesla가 아니라 Car라면 작동이 되겠지만..
						                  //지금 리턴 타입이 상위 타입이기 때문에 kim.buyCar("테슬라")는 빨간줄이 긁히는 것이다.
									   	  //즉 ,부모타입이 자식타입의 객체로 들어가는 것이기 때문이니, 강제로 타입을 끌어 내려줘야 한다.
		
		//이렇게 강제로 타입을 끌어 내리자
//		Tesla t5 = (Tesla)kim.buyCar("테슬라");
		//자식타입에 부모타입을 집어 넣는 것은 클래스를 새로 만들어서 설명 할 것이다.  클래스 만들러 가자 poly > casting > Parent 클래스로 가자.
		
		
		
		System.out.println("-------------------------------------------------------");
		
		
		
		
		
		//자식타입에 부모 타입을 집어 넣는다는 설명은 casting 패키지에 child, MainClass, Parent 클래스에 설명을 했다. 공부하고 다시 여기로 왔다.
		
		
		
		
		
		//다음 설명 할 것은, 일단 테슬라 클래스로 가자. 갔다가 다시 왔다. 호출하려고.
		//리턴타입 다형성 결과보러 왔다.
		Car c = kim.buyCar("테슬라"); //이건 문제가 없지.
		c.run();
		//이젠 테슬라 멤버쉽에 가입해서 혜택받고 싶은데
		//c.entermembership() 이 안불러진다.
		//부모의 시선으로 테슬라 객체를 보고 있기 때문에 자식의 고유 메서드를 볼 수가 없기 때문이다.
		//그래서 어떻게 할 것이냐?
		Tesla t5 = (Tesla) c; //강제 형변환 해줘야 주소값을 t5로 넘길 수 있다. 객체는 같지만 자식 타입의 변수를 선언해서, 이제는 다른 시선으로 자식의 객체를 보기 위해 주소만 넘겼다
		t5.enterMembership(); //이제야 가능.
		
		
		
		System.out.println("-------------------------------------------------------");
		
		
		//이제 인스턴스오브 를 배우자. car패키지에 CarShop을 생성해보자. 가보자.
		//인스턴스오브를 적용하고 호출하려 다시 돌아왔다.
		CarShop shop = new CarShop();
		shop.carPrice(s3);
		shop.carPrice(new Tesla());        //한번 부르는 용도로는 이런 것도 가능하다.
		shop.carPrice(kim.buyCar("포르쉐")); //한번 부르는 용도로는 이런 것도 가능하다. return new Porsche(); 객체가 carPrcie로 간다.
		//출력 결과 :
		/*
		소나타의 가격은 3000만원 입니다.
		테슬라의 가격은 7000만원 입니다.
		포르쉐를 구입합니다.
		포르쉐의 가격은 2억4천만원 입니다.
		*/
		
		
		
		
		
		
	}
}
