package oop.poly.casting;




public class MainClass {

	public static void main(String[] args) {
		
		//부모 객체를 생성해보자.
		Parent p = new Parent();
		p.n1 = 1;  //사용가능하다. Parent는 n1을 가지고 있으니까.
//		p.n2 = 2;  //불가능하다. n2는 자식에게 있기 때문이다. 부모는 자식이 뭘 갖고 있는지 모른다. 상속은 역전이 일어날 수 없기 때문이다.
		
		p.method1(); //가능. Parent가 가지고 있잖아.
		p.method2(); //가능. Parent가 가지고 있잖아.
//		p.method3(); //불가능. method3는 자식 것이기 때문에. 부모는 자식이 뭘 갖고 있는지 모른다.
		
		
		
		
		System.out.println("-----------------------------------------------------");
		
		
		
		//이번엔 자식 객체 생성해보자
		Child c = new Child();
		c.n1 = 1;   //부모한테 물려 받았기 때문에 가능
		c.n2 = 2;	//원래 자기가 들고 있었기 때문에 가능(자식의 고유 속성)
		
		c.method1();	//가능
		c.method2();	//가능
		c.method3();	//가능
		
		//출력 결과 :
		
		/*
		재정의한 1번 메서드 호출
		부모의 2번 메서드 호출
		자식 고유의 3번 메서드 호출
		*/
		
		
		
		
		
		
		System.out.println("-----------------------------------------------------");

		
		//이번엔 다형성 적용(promotion) 해보자.
		
		Parent p2 = new Child();	//부모타입의 변수에는 자식 객체를 생성할 수 있으니 문제가 안된다.
		p2.n1 = 1; 					//p2를 참조하여 n1에 1을 넣는다.
//		p2.n2 = 2; 					//이건 안들어간다. 
		
		p2.method1();
		p2.method2();
//		p2.method3();				//이건 안들어간다.
		
		//출력 결과 :
		
		/*
		재정의한 1번 메서드 호출    <-    p2라는 주소값의 객체가 실제로 Child객첸데, 사용이 안된다. 말이되는것인가..? p2의 타입이 Parent이기 때문에 p2.method3();는 안되는 것이다.
//		             			   즉, 부모의 시선에서는 자식의 정보를 모르니까..이것이 다형성의 단점이다.
		부모의 2번 메서드 호출
		*/
		
		
		
		
		
	     /*
		 	다형성이 적용되면 자식 클래스의 본래의 멤버(필드, 메서드)를 참조하지 못하는 문제가 발생한다.
		 	
		 	그래서 이를 하기 위해서 강제로 타입을 변환해야 한다.
		 */
		
		
		
		
		
		//그래서 어떻게해? 시선을 바꿔야지. 원래 자식의 시선으로. 즉, 강제 타입 변환 해야겠지.
//		  위 child c = new Child(); 가 아니라
		Child c2 = (Child) p2;    										//이것이 지금 부모 타입을 자식 타입으로 강제 변환(Down Casting)을 쓴 것이다.
		   															    //오해하지 말아야 하는게 이것은 객체를 새로 생성 한 것이 아니다.
																	    //접근 방식을 다르게 해준 것 뿐이다.
		c2.n2 = 2;     //자식 시선으로 다가가니 가능하게 된다.
		c2.method3();  //자식 시선으로 다가가니 가능하게 된다.
		
		System.out.println("p2의 주소값이 무엇이냐?" + p2);
		System.out.println("c2의 주소값이 무엇이냐?" + c2);
		//출력 결과 :
		//p2의 주소값이 무엇이냐?oop.poly.casting.Child@5e91993f
		//c2의 주소값이 무엇이냐?oop.poly.casting.Child@5e91993f
		
		
		
		
		
		
		
		
		
		//다형성이 한 번도 발생하지 않은 경우에는
		//강제 형 변환을 사용 할 수 없다.
		//일단 부모 객체를 생성해보자
		Parent ppp = new Parent();
		//그리고 형 변환을 해보자.
		Child c3 = (Child) ppp;  //새로운 c3 변수 생성 후, ppp라는 부모 객체 주소값에 child 타입을 강제로 끌어 내리고 대입했다. 위와 굉장히 유사하지만 다르다.
								 //아까는 부모 타입의 자식 객체가 들어있는 걸 자식으로 끌어 내려서 자식의 시선으로 보게 했지만
								 //이건 부모 객체를 자식 변수에 때려 넣었지만 빨간줄이 생성되지 않았다. 이 문법 자체는 문제가 없지만 
								 //실행 시키면 에러가 난다. 즉, 말이 안되는 문법이다.
							     //이러한 상황이 발생하기 때문에 자동 형변환을 시켜주지 않는 것이다. 자식 타입의 부모 객체란 없다.
	}
}
